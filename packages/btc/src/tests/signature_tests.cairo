use alexandria_btc::keys::{create_private_key, private_key_to_public_key};
use alexandria_btc::signature::{
    SIGHASH_ALL, Signature, create_signature_hash, mod_inverse, parse_der_signature,
    verify_signature, verify_transaction_signature,
};
use alexandria_btc::types::{BitcoinNetwork, BitcoinPublicKey};
use starknet::secp256_trait::Secp256Trait;
use starknet::secp256k1::Secp256k1Point;

#[test]
fn test_signature_verification_basic() {
    // Test with known good signature
    let private_key = create_private_key(
        0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef,
        BitcoinNetwork::Mainnet,
        true,
    );

    let public_key = private_key_to_public_key(private_key);

    // Create a test signature (this would normally be generated by signing)
    let signature = Signature {
        r: 0x9876543210fedcba9876543210fedcba9876543210fedcba9876543210fedcba,
        s: 0x1111222233334444555566667777888899aabbccddeeff001122334455667788,
    };

    let message_hash = 0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890;

    // Note: This test will likely fail as we're using arbitrary values
    // In practice, you'd use actual signature/message pairs
    let result = verify_signature(message_hash, signature, public_key);

    // For demonstration - in real tests you'd have known good signature pairs
    assert!(result == true || result == false, "Signature verification returned a boolean");
}

#[test]
fn test_signature_component_validation() {
    let public_key = BitcoinPublicKey {
        x: 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef,
        y: 0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321,
        compressed: true,
    };

    let message_hash = 0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890;

    // Test with r = 0 (should fail)
    let invalid_sig1 = Signature { r: 0, s: 1 };
    let result1 = verify_signature(message_hash, invalid_sig1, public_key);
    assert!(!result1, "Signature with r=0 should be invalid");

    // Test with s = 0 (should fail)
    let invalid_sig2 = Signature { r: 1, s: 0 };
    let result2 = verify_signature(message_hash, invalid_sig2, public_key);
    assert!(!result2, "Signature with s=0 should be invalid");

    // Test with message_hash = 0 (should fail)
    let valid_sig = Signature { r: 1, s: 1 };
    let result3 = verify_signature(0, valid_sig, public_key);
    assert!(!result3, "Verification with message_hash=0 should be invalid");
}

#[test]
fn test_der_signature_parsing() {
    // Valid DER signature: 30450220[32-byte r]0221[33-byte s with leading 00]
    let valid_der = array![
        0x30,
        0x45, // SEQUENCE, 69 bytes
        0x02,
        0x20, // INTEGER, 32 bytes (r)
        0x12,
        0x34,
        0x56,
        0x78,
        0x90,
        0xab,
        0xcd,
        0xef,
        0x12,
        0x34,
        0x56,
        0x78,
        0x90,
        0xab,
        0xcd,
        0xef,
        0x12,
        0x34,
        0x56,
        0x78,
        0x90,
        0xab,
        0xcd,
        0xef,
        0x12,
        0x34,
        0x56,
        0x78,
        0x90,
        0xab,
        0xcd,
        0xef,
        0x02,
        0x21, // INTEGER, 33 bytes (s with leading 00)
        0x00, // Leading zero to indicate positive number
        0xfe,
        0xdc,
        0xba,
        0x09,
        0x87,
        0x65,
        0x43,
        0x21,
        0xfe,
        0xdc,
        0xba,
        0x09,
        0x87,
        0x65,
        0x43,
        0x21,
        0xfe,
        0xdc,
        0xba,
        0x09,
        0x87,
        0x65,
        0x43,
        0x21,
        0xfe,
        0xdc,
        0xba,
        0x09,
        0x87,
        0x65,
        0x43,
        0x21,
    ];

    let result = parse_der_signature(valid_der.span());
    assert!(result.is_some(), "Valid DER signature should parse successfully");

    if let Option::Some(sig) = result {
        assert!(sig.r > 0, "Parsed r component should be non-zero");
        assert!(sig.s > 0, "Parsed s component should be non-zero");
    }
}

#[test]
fn test_der_signature_parsing_invalid() {
    // Invalid DER - wrong sequence tag
    let invalid_der1 = array![0x31, 0x45, 0x02, 0x20];
    let result1 = parse_der_signature(invalid_der1.span());
    assert!(result1.is_none(), "Invalid sequence tag should fail parsing");

    // Invalid DER - too short
    let invalid_der2 = array![0x30, 0x02];
    let result2 = parse_der_signature(invalid_der2.span());
    assert!(result2.is_none(), "Too short DER should fail parsing");

    // Invalid DER - wrong integer tag
    let invalid_der3 = array![0x30, 0x06, 0x03, 0x01, 0x01, 0x02, 0x01, 0x01];
    let result3 = parse_der_signature(invalid_der3.span());
    assert!(result3.is_none(), "Wrong integer tag should fail parsing");
}

#[test]
fn test_signature_hash_creation() {
    let transaction_data = array![
        0x01,
        0x00,
        0x00,
        0x00, // version
        0x01, // input count
        // ... (transaction input data would go here)
        0x01, // output count
        // ... (transaction output data would go here)
        0x00,
        0x00,
        0x00,
        0x00 // locktime
    ];

    let sig_hash = create_signature_hash(transaction_data.span(), SIGHASH_ALL);
    assert!(sig_hash != 0, "Signature hash should not be zero");

    // Test that different sighash types produce different hashes
    let sig_hash2 = create_signature_hash(transaction_data.span(), 0x02);
    assert!(sig_hash != sig_hash2, "Different sighash types should produce different hashes");
}

#[test]
fn test_transaction_signature_verification() {
    let private_key = create_private_key(
        0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef,
        BitcoinNetwork::Mainnet,
        true,
    );

    let public_key = private_key_to_public_key(private_key);

    let transaction_data = array![
        0x01,
        0x00,
        0x00,
        0x00, // version
        0x01, // input count
        0x01, // output count  
        0x00,
        0x00,
        0x00,
        0x00 // locktime
    ];

    // Test signature (in practice this would be created by signing the transaction hash)
    let signature = Signature {
        r: 0x9876543210fedcba9876543210fedcba9876543210fedcba9876543210fedcba,
        s: 0x1111222233334444555566667777888899aabbccddeeff001122334455667788,
    };

    let result = verify_transaction_signature(
        transaction_data.span(), signature, public_key, SIGHASH_ALL,
    );

    // This will likely fail as we're using arbitrary signature values
    // But it demonstrates the interface
    assert!(
        result == true || result == false, "Transaction signature verification returned a boolean",
    );
}

#[test]
fn test_curve_boundary_conditions() {
    let curve_size = Secp256Trait::<Secp256k1Point>::get_curve_size();

    let public_key = BitcoinPublicKey {
        x: 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef,
        y: 0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321,
        compressed: true,
    };

    let message_hash = 0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890;

    // Test with r >= curve_size (should fail)
    let invalid_sig1 = Signature { r: curve_size, s: 1 };
    let result1 = verify_signature(message_hash, invalid_sig1, public_key);
    assert!(!result1, "Signature with r >= curve_size should be invalid");

    // Test with s >= curve_size (should fail)
    let invalid_sig2 = Signature { r: 1, s: curve_size };
    let result2 = verify_signature(message_hash, invalid_sig2, public_key);
    assert!(!result2, "Signature with s >= curve_size should be invalid");

    // Test with message_hash >= curve_size (should fail)
    let valid_sig = Signature { r: 1, s: 1 };
    let result3 = verify_signature(curve_size, valid_sig, public_key);
    assert!(!result3, "Verification with message_hash >= curve_size should be invalid");
}

#[test]
fn test_modular_inverse_edge_cases() {
    // Test modular inverse of 1
    let inv1 = mod_inverse(1, 7);
    assert!(inv1 == 1, "Inverse of 1 mod 7 should be 1");

    // Test modular inverse of 0 (should return 0)
    let inv0 = mod_inverse(0, 7);
    assert!(inv0 == 0, "Inverse of 0 should be 0 (no inverse exists)");
}
